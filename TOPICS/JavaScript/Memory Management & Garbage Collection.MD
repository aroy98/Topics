# JavaScript Memory Management & Garbage Collection â€” Complete Reference with Examples

Memory management in JavaScript is largely **automatic**, thanks to the **Garbage Collector (GC)** in the **V8 engine** (used by Chrome and Node.js). However, understanding how memory is allocated, used, and reclaimed is essential for optimizing performance and preventing memory leaks.

---

## ğŸ§  Table of Contents

1. [What Is Memory Management?](#what-is-memory-management)
2. [JavaScript Memory Model](#javascript-memory-model)
3. [Stack vs Heap](#stack-vs-heap)
4. [Scopes and Closures](#scopes-and-closures)
5. [Garbage Collection Basics](#garbage-collection-basics)
6. [Mark-and-Sweep Algorithm](#mark-and-sweep-algorithm)
7. [Generational & Incremental GC](#generational--incremental-gc)
8. [Memory Leaks](#memory-leaks)
9. [Detecting Leaks in Browser](#detecting-leaks-in-browser)
10. [WeakMap, WeakSet & WeakRef](#weakmap-weakset--weakref)
11. [Node.js Memory Management](#nodejs-memory-management)
12. [Memory Profiling in Node.js](#memory-profiling-in-nodejs)
13. [Optimization Techniques](#optimization-techniques)
14. [Visual Memory Map](#visual-memory-map)
15. [Summary Table](#summary-table)

---

## ğŸ”¹ What Is Memory Management?

Memory management refers to how JavaScript **allocates**, **uses**, and **frees** memory during execution. JavaScript engines like **V8** handle this automatically, but developers can inadvertently create **memory leaks**.

---

## ğŸ”¹ JavaScript Memory Model

Memory is divided into two major regions:

* **Stack** â†’ Stores primitive values and function call frames.
* **Heap** â†’ Stores objects, arrays, and functions.

---

## ğŸ”¹ Stack vs Heap

### Stack (Static Memory)

* Fast access
* Fixed size (for function calls, primitives)

### Heap (Dynamic Memory)

* Large, flexible
* Used for objects, closures, arrays

### Example

```js
function add(a, b) {
  const result = a + b; // Stored in stack
  const obj = { sum: result }; // Stored in heap
  return obj;
}
```

---

## ğŸ”¹ Scopes and Closures

Closures keep references to their outer variables â€” preventing them from being garbage-collected.

```js
function outer() {
  let count = 0;
  return function inner() {
    count++; // 'count' stays in memory
    console.log(count);
  };
}

const counter = outer();
counter();
```

âš ï¸ If closures reference large objects, they can cause **memory retention**.

---

## ğŸ”¹ Garbage Collection Basics

Garbage collection is **automatic** but not instantaneous.
The GC removes objects **no longer reachable** from the root (`window` in browser, `global` in Node.js).

```js
let user = { name: 'Alice' };
user = null; // Object is unreachable â†’ eligible for GC
```

---

## ğŸ”¹ Mark-and-Sweep Algorithm

Most engines (like V8) use **Mark-and-Sweep** GC:

1. **Mark phase** â€” Traverse object graph from roots (global objects).
2. **Sweep phase** â€” Delete all unmarked (unreachable) objects.

### Diagram

```
[Root] â†’ [Object A] â†’ [Object B]
           â†“
        [Object C]

If A loses reference to B â†’ B and C become unreachable â†’ GC removes them.
```

---

## ğŸ”¹ Generational & Incremental GC

Modern GC optimizes performance via multiple techniques:

### ğŸ§© Generational GC

* Divides objects into **young** (new) and **old** (long-lived) generations.
* Young objects are collected frequently.
* Old objects are collected less often.

### ğŸ” Incremental GC

* GC runs in **small steps** to avoid blocking execution.

### ğŸ§µ Concurrent GC

* Runs in a separate thread in V8 â€” minimal pause time.

---

## ğŸ”¹ Memory Leaks

A **memory leak** occurs when unreachable objects remain referenced and never freed.

### Common Causes

1. **Global variables**

   ```js
   leaked = []; // Implicit global
   ```
2. **Forgotten timers/listeners**

   ```js
   setInterval(() => console.log('leak'), 1000); // Never cleared
   ```
3. **Closures retaining references**

   ```js
   function createLeak() {
     const large = new Array(100000).fill('*');
     return () => console.log(large.length);
   }
   ```
4. **Detached DOM elements**

   ```js
   const div = document.createElement('div');
   document.body.appendChild(div);
   div.remove(); // Still referenced â†’ memory leak
   ```

---

## ğŸ”¹ Detecting Leaks in Browser

Use **Chrome DevTools**:

1. Open **Performance â†’ Memory tab**.
2. Take heap snapshots.
3. Compare retained objects before and after.

### Tools

* **Performance Monitor** â€” real-time JS memory usage.
* **Lighthouse** â€” audits for leaks.

---

## ğŸ”¹ WeakMap, WeakSet & WeakRef

### WeakMap

* Keys are **weakly referenced** â†’ if no other reference, theyâ€™re GCâ€™d.

```js
let obj = { name: 'Alice' };
const weakMap = new WeakMap();
weakMap.set(obj, 'metadata');
obj = null; // Automatically garbage collected
```

### WeakSet

* Works like WeakMap but only holds objects.

### WeakRef (ES2021)

* Allows weak reference to object without preventing GC.

```js
let user = { name: 'Bob' };
const weak = new WeakRef(user);
user = null;
console.log(weak.deref()); // May return undefined after GC
```

---

## ğŸ”¹ Node.js Memory Management

### V8 Heap Structure

* **New Space (Young Gen)** â€” small, frequent GC.
* **Old Space (Old Gen)** â€” long-lived objects.
* **Large Object Space** â€” huge objects.

### Check Memory Usage

```js
console.log(process.memoryUsage());
```

Example Output:

```js
{
  rss: 23592960,
  heapTotal: 6586368,
  heapUsed: 4576208,
  external: 105472
}
```

### Increase Memory Limit

Default Node.js limit â‰ˆ 2 GB. To increase:

```bash
node --max-old-space-size=4096 app.js
```

---

## ğŸ”¹ Memory Profiling in Node.js

### 1. Using Chrome DevTools

Run Node with inspect flag:

```bash
node --inspect-brk app.js
```

Open **chrome://inspect** â†’ Take snapshots.

### 2. Using Built-in Inspector

```js
const inspector = require('inspector');
inspector.open(9229, null, true);
```

### 3. Monitoring

```js
setInterval(() => {
  const { heapUsed, heapTotal } = process.memoryUsage();
  console.log(`Heap used: ${(heapUsed / 1024 / 1024).toFixed(2)} MB`);
}, 3000);
```

---

## ğŸ”¹ Optimization Techniques

âœ… **Nullify references** when no longer needed:

```js
obj = null;
```

âœ… **Use WeakMap/WeakSet** for ephemeral data.
âœ… **Unsubscribe** event listeners.
âœ… **Throttle/debounce** DOM events.
âœ… Avoid **storing DOM nodes** in closures.
âœ… Keep functions short-lived.

---

## ğŸ”¹ Visual Memory Map

```
      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â”‚          Call Stack          â”‚
      â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚
      â”‚ add() â†’ local vars          â”‚
      â”‚ compute() â†’ primitives      â”‚
      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â”‚ references
                     â–¼
      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â”‚             Heap              â”‚
      â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚
      â”‚ Object: { name: 'Alice' }   â”‚
      â”‚ Array: [1,2,3]              â”‚
      â”‚ Closure: { counter: 5 }     â”‚
      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

   GC Root â†’ Stack â†’ Heap objects â†’ Mark & Sweep unreferenced
```

---

## ğŸ”¹ Summary Table

| Concept         | Description              | Example                   |
| --------------- | ------------------------ | ------------------------- |
| Stack           | Fast, stores primitives  | `let x = 10;`             |
| Heap            | Dynamic, stores objects  | `{ key: 'value' }`        |
| GC              | Automatic cleanup        | Mark-and-sweep            |
| Generational GC | Divides objects by age   | Young/Old spaces          |
| Memory Leak     | Unreleased references    | Event listeners, closures |
| WeakMap         | GC-safe key-value store  | `weakMap.set(obj, data)`  |
| WeakRef         | Weak reference to object | `new WeakRef(obj)`        |
| DevTools        | Browser memory profiling | Heap snapshots            |
| Node Flags      | Increase memory          | `--max-old-space-size`    |

---

### âœ… In Short

* JS memory is divided into **stack** (primitives) and **heap** (objects).
* **Garbage collection** is automatic but depends on reachability.
* Use **WeakMap/WeakRef** to avoid leaks.
* Always remove **event listeners** and **intervals**.
* Monitor memory using **DevTools** or **process.memoryUsage()** in Node.js.

---

**Next Suggested Topic:** ğŸ§© *JavaScript Error Handling, Debugging, and Performance Optimization â€” Complete Reference with Examples*
