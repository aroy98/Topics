# üß† TypeScript Mastery Series ‚Äì Part X: Advanced Practices & Design Patterns

---

## üìò Table of Contents

1. [Introduction](#introduction)
2. [Type-Driven Development](#type-driven-development)
3. [Domain Modeling with Types](#domain-modeling-with-types)
4. [Declarative vs Imperative Typing](#declarative-vs-imperative-typing)
5. [Applying Design Patterns in TypeScript](#applying-design-patterns-in-typescript)

   * [Singleton Pattern](#singleton-pattern)
   * [Factory Pattern](#factory-pattern)
   * [Strategy Pattern](#strategy-pattern)
   * [Observer Pattern](#observer-pattern)
   * [Decorator Pattern](#decorator-pattern)
6. [Advanced Inference and Type Composition](#advanced-inference-and-type-composition)
7. [Best Practices for Large-Scale Projects](#best-practices-for-large-scale-projects)
8. [Summary](#summary)

---

## üß† Introduction

This final part of the TypeScript Mastery Series focuses on **advanced type-level programming** and **object-oriented design patterns**. You‚Äôll learn how to apply design principles with TypeScript‚Äôs strong type system for maintainable and scalable codebases.

---

## üß© Type-Driven Development

Type-driven development (TDD with types) focuses on designing robust types before writing actual logic.

### Example

```ts
type User = {
  id: string;
  name: string;
  email: string;
  verified: boolean;
};

function verifyUser(user: User): User {
  return { ...user, verified: true };
}
```

Here, the **types define the domain contracts** before implementation begins, reducing logical errors early.

---

## üèóÔ∏è Domain Modeling with Types

Domain modeling helps describe real-world entities using TypeScript‚Äôs types and interfaces.

### Example: Banking Domain

```ts
type AccountType = 'savings' | 'current';

type Account = {
  id: string;
  holderName: string;
  type: AccountType;
  balance: number;
};

function deposit(account: Account, amount: number): Account {
  return { ...account, balance: account.balance + amount };
}
```

### Benefits:

* Enforces domain boundaries
* Prevents invalid state
* Improves refactoring safety

---

## ‚öñÔ∏è Declarative vs Imperative Typing

TypeScript allows you to describe logic declaratively with types rather than imperative code.

### Imperative Example

```ts
function getFirst(arr: any[]) {
  return arr[0];
}
```

### Declarative Example

```ts
function getFirst<T>(arr: T[]): T {
  return arr[0];
}
```

Declarative typing with generics leads to safer and reusable code.

---

## üß© Applying Design Patterns in TypeScript

TypeScript enhances classical design patterns by enforcing strong type rules.

---

### üßç‚Äç‚ôÇÔ∏è Singleton Pattern

Ensures only one instance of a class exists.

```ts
class Database {
  private static instance: Database;

  private constructor() {}

  static getInstance(): Database {
    if (!Database.instance) {
      Database.instance = new Database();
    }
    return Database.instance;
  }
}

const db1 = Database.getInstance();
const db2 = Database.getInstance();
console.log(db1 === db2); // true
```

---

### üè≠ Factory Pattern

Creates objects without exposing instantiation logic.

```ts
interface Car {
  drive(): void;
}

class Sedan implements Car {
  drive() {
    console.log('Driving a Sedan');
  }
}

class SUV implements Car {
  drive() {
    console.log('Driving an SUV');
  }
}

class CarFactory {
  static createCar(type: 'sedan' | 'suv'): Car {
    if (type === 'sedan') return new Sedan();
    return new SUV();
  }
}

const myCar = CarFactory.createCar('suv');
myCar.drive();
```

---

### ‚öôÔ∏è Strategy Pattern

Defines a family of algorithms and makes them interchangeable.

```ts
interface PaymentStrategy {
  pay(amount: number): void;
}

class PayPalPayment implements PaymentStrategy {
  pay(amount: number) {
    console.log(`Paid $${amount} using PayPal`);
  }
}

class CreditCardPayment implements PaymentStrategy {
  pay(amount: number) {
    console.log(`Paid $${amount} using Credit Card`);
  }
}

class PaymentContext {
  constructor(private strategy: PaymentStrategy) {}

  setStrategy(strategy: PaymentStrategy) {
    this.strategy = strategy;
  }

  executePayment(amount: number) {
    this.strategy.pay(amount);
  }
}

const context = new PaymentContext(new PayPalPayment());
context.executePayment(100);
context.setStrategy(new CreditCardPayment());
context.executePayment(250);
```

---

### üëÄ Observer Pattern

Defines a one-to-many dependency between objects so when one changes, others are notified.

```ts
interface Observer {
  update(data: string): void;
}

class Subject {
  private observers: Observer[] = [];

  subscribe(observer: Observer) {
    this.observers.push(observer);
  }

  unsubscribe(observer: Observer) {
    this.observers = this.observers.filter(o => o !== observer);
  }

  notify(data: string) {
    this.observers.forEach(o => o.update(data));
  }
}

class ConcreteObserver implements Observer {
  constructor(private name: string) {}
  update(data: string) {
    console.log(`${this.name} received: ${data}`);
  }
}

const subject = new Subject();
const obs1 = new ConcreteObserver('Observer 1');
const obs2 = new ConcreteObserver('Observer 2');

subject.subscribe(obs1);
subject.subscribe(obs2);
subject.notify('New event occurred!');
```

---

### üé® Decorator Pattern

Adds new behavior to objects dynamically.

```ts
interface Coffee {
  cost(): number;
  description(): string;
}

class SimpleCoffee implements Coffee {
  cost() {
    return 5;
  }
  description() {
    return 'Simple Coffee';
  }
}

class MilkDecorator implements Coffee {
  constructor(private coffee: Coffee) {}
  cost() {
    return this.coffee.cost() + 2;
  }
  description() {
    return `${this.coffee.description()} + Milk`;
  }
}

const myCoffee = new MilkDecorator(new SimpleCoffee());
console.log(myCoffee.description()); // Simple Coffee + Milk
console.log(myCoffee.cost()); // 7
```

---

## üß¨ Advanced Inference and Type Composition

TypeScript‚Äôs advanced inference allows building powerful type transformations.

### Example: Extracting Return Type

```ts
type ReturnType<T> = T extends (...args: any[]) => infer R ? R : never;

function getUser() {
  return { id: 1, name: 'Akash' };
}

type User = ReturnType<typeof getUser>; // { id: number; name: string }
```

### Example: Deep Partial

```ts
type DeepPartial<T> = {
  [K in keyof T]?: T[K] extends object ? DeepPartial<T[K]> : T[K];
};

interface Project {
  id: number;
  name: string;
  details: {
    budget: number;
    duration: string;
  };
}

const project: DeepPartial<Project> = {
  details: { budget: 10000 }
};
```

---

## üß± Best Practices for Large-Scale Projects

‚úÖ Use **strict mode** and never disable type checks.
‚úÖ Prefer **composition** over inheritance for flexibility.
‚úÖ Create **type-safe domain models** before implementing logic.
‚úÖ Use **utility types** (`Partial`, `Pick`, `Omit`) for cleaner code.
‚úÖ Keep **interfaces** and **types** centralized in `/types` folder.
‚úÖ Implement **design patterns** where they simplify code‚Äînot just for theory.
‚úÖ Leverage **type inference** to reduce redundancy.

---

## üßæ Summary

* TypeScript supports **classic design patterns** like Singleton, Factory, Strategy, Observer, and Decorator.
* Use **type-driven development** for predictable, maintainable applications.
* Apply **domain modeling** to align code with business rules.
* Prefer **composition**, **generics**, and **inference** to build scalable systems.
* Advanced type utilities allow declarative, type-safe architecture.

---

üéâ **Congratulations!** You‚Äôve completed the **TypeScript Mastery Series (Parts I‚ÄìX)** ‚Äî from fundamentals to advanced design patterns. You‚Äôre now fully equipped to build production-grade TypeScript applications with confidence.
